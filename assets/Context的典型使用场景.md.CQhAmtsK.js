import{_ as e,c as l,a0 as a,o as d}from"./chunks/framework.CGHvQLJz.js";const f=JSON.parse('{"title":"Context的典型使用场景","description":"","frontmatter":{},"headers":[],"relativePath":"Context的典型使用场景.md","filePath":"Context的典型使用场景.md","lastUpdated":null}'),i={name:"Context的典型使用场景.md"};function n(o,t,r,s,x,g){return d(),l("div",null,t[0]||(t[0]=[a('<h1 id="context的典型使用场景" tabindex="-1">Context的典型使用场景 <a class="header-anchor" href="#context的典型使用场景" aria-label="Permalink to &quot;Context的典型使用场景&quot;">​</a></h1><h2 id="获取应用文件路径" tabindex="-1">获取应用文件路径 <a class="header-anchor" href="#获取应用文件路径" aria-label="Permalink to &quot;获取应用文件路径&quot;">​</a></h2><p>基类Context提供了获取应用文件路径的能力，ApplicationContext、AbilityStageContext、UIAbilityContext和ExtensionContext均继承该能力。应用文件路径属于应用沙箱路径，上述各类Context获取的应用文件路径有所不同。</p><p>通过ApplicationContext获取应用级别的应用文件路径，此路径是应用全局信息推荐的存放路径，这些文件会跟随应用的卸载而删除</p><table tabindex="0"><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">路径</th></tr></thead><tbody><tr><td style="text-align:left;">bundleCodeDir</td><td style="text-align:left;">&lt;路径前缀&gt;/el1/bundle</td></tr><tr><td style="text-align:left;">cacheDir</td><td style="text-align:left;">&lt;路径前缀&gt;/&lt;加密等级&gt;/base/cache</td></tr><tr><td style="text-align:left;">filesDir</td><td style="text-align:left;">&lt;路径前缀&gt;/&lt;加密等级&gt;/base/files</td></tr><tr><td style="text-align:left;">preferencesDir</td><td style="text-align:left;">&lt;路径前缀&gt;/&lt;加密等级&gt;/base/preferences</td></tr><tr><td style="text-align:left;">tempDir</td><td style="text-align:left;">&lt;路径前缀&gt;/&lt;加密等级&gt;/base/temp</td></tr><tr><td style="text-align:left;">databaseDir</td><td style="text-align:left;">&lt;路径前缀&gt;/&lt;加密等级&gt;/database</td></tr><tr><td style="text-align:left;">distributedFilesDir</td><td style="text-align:left;">&lt;路径前缀&gt;/el2/distributedFiles</td></tr><tr><td style="text-align:left;">cloudFileDir</td><td style="text-align:left;">&lt;路径前缀&gt;/el2/cloud</td></tr></tbody></table><p>通过AbilityStageContext、UIAbilityContext、ExtensionContext获取HAP级别的应用文件路径。此路径是HAP相关信息推荐的存放路径，这些文件会跟随HAP的卸载而删除，但不会影响应用级别路径的文件，除非该应用的HAP已全部卸载。</p><table tabindex="0"><thead><tr><th style="text-align:left;">属性</th><th style="text-align:left;">路径</th></tr></thead><tbody><tr><td style="text-align:left;">bundleCodeDir</td><td style="text-align:left;"><code>&lt;路径前缀&gt;/el1/bundle</code></td></tr><tr><td style="text-align:left;">cacheDir</td><td style="text-align:left;"><code>&lt;路径前缀&gt;/&lt;加密等级&gt;/base/haps/&lt;module-name&gt;/cache</code></td></tr><tr><td style="text-align:left;">filesDir</td><td style="text-align:left;"><code>&lt;路径前缀&gt;/&lt;加密等级&gt;/base/haps/&lt;module-name&gt;/files</code></td></tr><tr><td style="text-align:left;">preferencesDir</td><td style="text-align:left;"><code>&lt;路径前缀&gt;/&lt;加密等级&gt;/base/haps/&lt;module-name&gt;/preferences</code></td></tr><tr><td style="text-align:left;">tempDir</td><td style="text-align:left;"><code>&lt;路径前缀&gt;/&lt;加密等级&gt;/base/haps/&lt;module-name&gt;/temp</code></td></tr><tr><td style="text-align:left;">databaseDir</td><td style="text-align:left;"><code>&lt;路径前缀&gt;/&lt;加密等级&gt;/database/&lt;module-name&gt;</code></td></tr><tr><td style="text-align:left;">distributedFilesDir</td><td style="text-align:left;"><code>&lt;路径前缀&gt;/el2/distributedFiles/&lt;module-name&gt;</code></td></tr><tr><td style="text-align:left;">cloudFileDir</td><td style="text-align:left;"><code>&lt;路径前缀&gt;/el2/cloud/&lt;module-name&gt;</code></td></tr></tbody></table><h2 id="获取和修改加密分区" tabindex="-1">获取和修改加密分区 <a class="header-anchor" href="#获取和修改加密分区" aria-label="Permalink to &quot;获取和修改加密分区&quot;">​</a></h2><p>应用文件加密是一种保护数据安全的方法，可以使得文件在未经授权访问的情况下得到保护。在不同的场景下，应用需要不同程度的文件保护。在实际应用中，开发者需要根据不同场景的需求选择合适的加密分区，从而保护应用数据的安全。通过合理使用不同级别的加密分区，可以有效提高应用数据的安全性。</p><ul><li>EL1：对于私有文件，如闹铃、壁纸等，应用可以将这些文件放到设备级加密分区（EL1）中，以保证在用户输入密码前就可以被访问。</li><li>EL2：对于更敏感的文件，如个人隐私信息等，应用可以将这些文件放到更高级别的加密分区（EL2）中，以保证更高的安全性。</li><li>EL3：对于应用中的记录步数、文件下载、音乐播放，需要在锁屏时读写和创建新文件，放在（EL3）的加密分区比较合适。</li><li>EL4：对于用户安全信息相关的文件，锁屏时不需要读写文件、也不能创建文件，放在（EL4）的加密分区更合适。</li><li>EL5：对于用户隐私敏感数据文件，锁屏后默认不可读写，如果锁屏后需要读写文件，则锁屏前可以调用Access接口申请继续读写文件，或者锁屏后也需要创建新文件且可读写，放在（EL5）的应用级加密分区更合适</li></ul><h2 id="获取本应用中其他module的context" tabindex="-1">获取本应用中其他module的context <a class="header-anchor" href="#获取本应用中其他module的context" aria-label="Permalink to &quot;获取本应用中其他module的context&quot;">​</a></h2><p>调用createModuleContext(moduleName:string)方法，获取本应用中其他Module的Context。获取到其他Module的Context之后，即可获取到相应Module的资源信息。</p><h2 id="订阅进程内uiability生命周期变化" tabindex="-1">订阅进程内UIAbility生命周期变化 <a class="header-anchor" href="#订阅进程内uiability生命周期变化" aria-label="Permalink to &quot;订阅进程内UIAbility生命周期变化&quot;">​</a></h2><p>在应用内的DFX统计场景中，如需要统计对应页面停留时间和访问频率等信息，可以使用订阅进程内UIAbility生命周期变化功能。</p><p>通过ApplicationContext提供的能力，可以订阅进程内UIAbility生命周期变化。当进程内的UIAbility生命周期变化时，如创建、可见/不可见、获焦/失焦、销毁等，会触发相应的回调函数。每次注册回调函数时，都会返回一个监听生命周期的ID，此ID会自增+1。当超过监听上限数量2^63-1时，会返回-1</p>',15)]))}const b=e(i,[["render",n]]);export{f as __pageData,b as default};
