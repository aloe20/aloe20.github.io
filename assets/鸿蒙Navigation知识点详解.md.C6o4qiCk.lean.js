import{_ as i,c as t,a0 as e,o as n}from"./chunks/framework.CGHvQLJz.js";const u=JSON.parse('{"title":"鸿蒙Navigation知识点详解","description":"","frontmatter":{},"headers":[],"relativePath":"鸿蒙Navigation知识点详解.md","filePath":"鸿蒙Navigation知识点详解.md","lastUpdated":null}'),o={name:"鸿蒙Navigation知识点详解.md"};function l(r,a,s,c,d,h){return n(),t("div",null,a[0]||(a[0]=[e('<h1 id="鸿蒙navigation知识点详解" tabindex="-1">鸿蒙Navigation知识点详解 <a class="header-anchor" href="#鸿蒙navigation知识点详解" aria-label="Permalink to &quot;鸿蒙Navigation知识点详解&quot;">​</a></h1><p>Navigation是路由导航的根视图容器，一般作为页面（@Entry）的根容器，包括单栏（Stack）、分栏（Split）和自适应（Auto）三种显示模式。Navigation组件适用于模块内和跨模块的路由切换，通过组件级路由能力实现更加自然流畅的转场体验，并提供多种标题栏样式来呈现更好的标题和内容联动效果。一次开发，多端部署场景下，Navigation组件能够自动适配窗口显示大小，在窗口较大的场景下自动切换分栏展示效果。</p><p>Navigation组件主要包含​导航页（NavBar）和子页（NavDestination）。导航页由标题栏（Titlebar，包含菜单栏menu）、内容区（Navigation子组件）和工具栏（Toolbar）组成，其中导航页可以通过hideNavBar属性进行隐藏，导航页不存在页面栈中，导航页和子页，以及子页之间可以通过路由操作进行切换。</p><h2 id="页面显示模式" tabindex="-1">页面显示模式 <a class="header-anchor" href="#页面显示模式" aria-label="Permalink to &quot;页面显示模式&quot;">​</a></h2><p>Navigation组件通过mode属性设置页面的显示模式。显示模式有三种，默认Auto自适应模式、Stack单页面模式和Split分栏模式。Navigation组件默认为自适应模式，此时mode属性为NavigationMode.Auto。自适应模式下，当页面宽度大于等于一定阈值( API version 9及以前：520vp，API version 10及以后：600vp )时，Navigation组件采用分栏模式，反之采用单栏模式。 <img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20241112102720.04748425351894099476903677486844:50001231000000:2800:D57BA1151AEA1D7F97C8652C4F7DA417EE0E9D5F74B92D5CC825FCA6015CA9A2.png" alt="单页面模式"><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20241112102721.97898286928849784319660832837271:50001231000000:2800:FDCB84A81034854A05F4DCDC4369856529C81442131CDF11FCE70183AC16E69B.png" alt="分栏模式"></p><h2 id="标题栏模式" tabindex="-1">标题栏模式 <a class="header-anchor" href="#标题栏模式" aria-label="Permalink to &quot;标题栏模式&quot;">​</a></h2><p>标题栏在界面顶部，用于呈现界面名称和操作入口，Navigation组件通过titleMode属性设置标题栏模式。标题栏有Mini模式，普通型标题栏，用于一级页面不需要突出标题的场景；Full模式，强调型标题栏，用于一级页面需要突出标题的场景。Free模式，当内容为满一屏的可滚动组件时，标题随着内容向上滚动而缩小（子标题的大小不变、淡出）。向下滚动内容到顶时则恢复原样等三种模式。 <img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20241112102721.32129227584410776631430183789548:50001231000000:2800:D7798A1AD8B2A983B578ED74D84FCE62CD8ED0114A03FBEFA331EA61AF75899F.jpg" alt="mini模式"><img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20241112102721.72557026441012619928565449610421:50001231000000:2800:0EBB655EF7BCE180E1B1E46729E7BE22EAFABBBD37178BB490D751E3FA3FADFA.jpg" alt="full模式"></p><h2 id="菜单栏" tabindex="-1">菜单栏 <a class="header-anchor" href="#菜单栏" aria-label="Permalink to &quot;菜单栏&quot;">​</a></h2><p>菜单栏位于Navigation组件的右上角，开发者可以通过menus属性进行设置。menus支持Array&lt;NavigationMenuItem&gt;和CustomBuilder两种参数类型。使用Array&lt;NavigationMenuItem&gt;类型时，竖屏最多支持显示3个图标，横屏最多支持显示5个图标，多余的图标会被放入自动生成的更多图标。 <img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20241112102721.34043326045120758914991792810181:50001231000000:2800:C95A0E5B8201E97A4C7DA055B7E17856BDE88CB1ECD5E5D2C27FB749AE621313.jpg" alt="菜单栏"></p><h2 id="工具栏" tabindex="-1">工具栏 <a class="header-anchor" href="#工具栏" aria-label="Permalink to &quot;工具栏&quot;">​</a></h2><p>工具栏位于Navigation组件的底部，开发者可以通过toolbarConfiguration属性进行设置。 <img src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20241112102721.22879643756958963772395227067599:50001231000000:2800:F4AD7EC847F6F5C272D9E8FC79BFAD896DC52685B973A21B52D366BD0E60004B.jpg" alt="img"></p><h2 id="路由操作" tabindex="-1">路由操作 <a class="header-anchor" href="#路由操作" aria-label="Permalink to &quot;路由操作&quot;">​</a></h2><p>Navigation路由相关的操作都是基于页面栈NavPathStack提供的方法进行，每个Navigation都需要创建并传入一个NavPathStack对象，用于管理页面。主要涉及页面跳转、页面返回、页面替换、页面删除、参数获取、路由拦截等功能。</p><ul><li>页面跳转：使用pushPath或pushPathByName打开一个新页面</li><li>页面返回：使用pop、popToName或popToIndex返回上一个页面或返回到指定页面</li><li>页面替换：使用replacePath或replacePathByName替换当前页面</li><li>页面删除：使用removeByName或removeByIndexes删除指定页面</li></ul><h2 id="子页面" tabindex="-1">子页面 <a class="header-anchor" href="#子页面" aria-label="Permalink to &quot;子页面&quot;">​</a></h2><p>NavDestination是Navigation子页面的根容器，用于承载子页面的一些特殊属性以及生命周期等。NavDestination可以设置独立的标题栏和菜单栏等属性，使用方法与Navigation相同。NavDestination也可以通过mode属性设置不同的显示类型，用于满足不同页面的诉求。</p><p>子页面有两个类型，分为标准类型NavDestinationMode.STANDARD，其生命周期跟随其在NavPathStack页面栈中的位置变化而改变。以及弹窗类型NavDestinationMode.DIALOG，此时整个NavDestination默认透明显示，弹窗类型的NavDestination显示和消失时不会影响下层标准类型的NavDestination的显示和生命周期，两者可以同时显示。</p><h2 id="页面监听和查询" tabindex="-1">页面监听和查询 <a class="header-anchor" href="#页面监听和查询" aria-label="Permalink to &quot;页面监听和查询&quot;">​</a></h2><p>为了方便组件跟页面解耦，在NavDestination子页面内部的自定义组件可以通过全局方法监听或查询到页面的一些状态信息。</p><ul><li>页面信息查询：自定义组件提供queryNavDestinationInfo方法，可以在NavDestination内部查询到当前所属页面的信息，返回值为NavDestinationInfo，若查询不到则返回undefined。</li><li>页面状态监听：通过observer.on(&#39;navDestinationUpdate&#39;)提供的注册接口可以注册NavDestination生命周期变化的监听，也可以注册页面切换的状态回调，能在页面发生路由切换的时候拿到对应的页面信息NavDestinationSwitchInfo，并且提供了UIAbilityContext和UIContext不同范围的监听。</li></ul><h2 id="页面转场" tabindex="-1">页面转场 <a class="header-anchor" href="#页面转场" aria-label="Permalink to &quot;页面转场&quot;">​</a></h2><p>Navigation默认提供了页面切换的转场动画，通过页面栈操作时，会触发不同的转场效果（Dialog类型的页面默认无转场动画），Navigation也提供了关闭系统转场、自定义转场以及共享元素转场的能力。</p><h3 id="关闭转场" tabindex="-1">关闭转场 <a class="header-anchor" href="#关闭转场" aria-label="Permalink to &quot;关闭转场&quot;">​</a></h3><ul><li>全局关闭：Navigation通过NavPathStack中提供的disableAnimation方法可以在当前Navigation中关闭或打开所有转场动画。</li><li>单次关闭：NavPathStack中提供的Push、Pop、Replace等接口中可以设置animated参数，默认为true表示有转场动画，需要单次关闭转场动画可以置为false，不影响下次转场动画。</li></ul><h3 id="自定义转场" tabindex="-1">自定义转场 <a class="header-anchor" href="#自定义转场" aria-label="Permalink to &quot;自定义转场&quot;">​</a></h3><p>Navigation通过customNavContentTransition事件提供自定义转场动画的能力，通过如下三步可以定义一个自定义的转场动画。</p><ol><li>构建一个自定义转场动画工具类CustomNavigationUtils，通过一个Map管理各个页面自定义动画对象CustomTransition，页面在创建的时候将自己的自定义转场动画对象注册进去，销毁的时候解注册；</li><li>实现一个转场协议对象NavigationAnimatedTransition，其中timeout属性表示转场结束的超时时间，默认为1000ms，transition属性为自定义的转场动画方法，开发者要在这里实现自己的转场动画逻辑，系统会在转场开始时调用该方法，onTransitionEnd为转场结束时的回调。</li><li>调用customNavContentTransition方法，返回实现的转场协议对象，如果返回undefined，则使用系统默认转场。</li></ol><h3 id="共享元素转场" tabindex="-1">共享元素转场 <a class="header-anchor" href="#共享元素转场" aria-label="Permalink to &quot;共享元素转场&quot;">​</a></h3><p>NavDestination之间切换时可以通过geometryTransition实现共享元素转场。配置了共享元素转场的页面同时需要关闭系统默认的转场动画。</p><ol><li>为需要实现共享元素转场的组件添加geometryTransition属性，id参数必须在两个NavDestination之间保持一致。</li><li>将页面路由的操作，放到animateTo动画闭包中，配置对应的动画参数以及关闭系统默认的转场。</li></ol><h2 id="跨包动态路由" tabindex="-1">跨包动态路由 <a class="header-anchor" href="#跨包动态路由" aria-label="Permalink to &quot;跨包动态路由&quot;">​</a></h2><p>通过静态import页面再进行路由跳转的方式会造成不同模块之间的依赖耦合，以及首页加载时间长等问题。动态路由设计的初衷旨在解决多个模块（HAR/HSP）能够复用相同的业务逻辑，实现各业务模块间的解耦，同时支持路由功能的扩展与整合。</p><p>动态路由提供系统路由表和自定义路由表两种实现方式。支持自定义路由表和系统路由表混用。</p><ul><li>系统路由表相对自定义路由表，使用更简单，只需要添加对应页面跳转配置项，即可实现页面跳转。</li><li></li></ul><p>自定义路由表使用起来更复杂，但是可以根据应用业务进行定制处理。</p>',35)]))}const v=i(o,[["render",l]]);export{u as __pageData,v as default};
